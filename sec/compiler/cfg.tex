\subsection{Low-level Optimizations}\label{sec:compiler:cfg}

The low-level \gls{IR} in \factor|compiler.cfg| takes the more conventional
form of a \gls{CFG}.  A \gls{CFG} (not to be confused with ``context-free
grammar'') is an arrangement of instructions into \term{basic blocks}: maximal
sequences of ``straight-line'' code, where control does not transfer out of or
into the middle of the block.  Directed edges are added between blocks to
represent control flow---either from a branching instruction to its target, or
from the end of a basic block to the start of the next one\todo{cite}.
Construction of the low-level \gls{IR} proceeds by analyzing the control flow
of the high-level \gls{IR} and converting the nodes of \cref{sec:compiler:tree}
into lower-level, more conventional instructions modeled after typical assembly
code.  There are over a hundred of these instructions, but many are simply
different versions of the same operation.  For instance, while instructions are
generally called on \term{virtual registers} (represented in Factor simply by
integers), there are \term{immediate} versions of instructions.  The
\factor|##add| instruction, as an example, represents the sum of the contents
of two registers, but \factor|##add-imm| sums the contents of one register and
an integer literal.  Other instructions are inserted to make stack reads and
writes explicit, as well as to balance the height.  Below is a categorized list
of all the instruction objects (each one is a subclass of the \factor|insn|
tuple).

\todo[inline]{Is the complete list really necessary?}
\input{sec/compiler/insns}

% dls.pdf verbatim:

%Low-level IR is built from high-level IR by analyzing control flow and making
%stack reads and writes explicit. During this construction phase and a
%subsequent branch splitting phase, the SSA structure of high-level IR is lost.
%SSA form is reconstructed using the SSA construction algorithm described in
%[8], with the minor variation that we construct pruned SSA form rather than
%semi-pruned SSA, by first computing liveness. To avoid computing iterated
%dominance frontiers, we use the TDMSC algorithm from [13]. 

%The main optimizations performed on low-level IR are local dead store and
%redundant load elimination, local value numbering, global copy propagation,
%representation selection, and instruction scheduling.  The local value
%numbering pass eliminates common subexpressions and folds expressions with
%constant operands [9].

%Following value numbering and copy propagation, a representation selection
%pass decides when to unbox floating point and SIMD values. A form of
%instruction scheduling intended to reduce register pressure is performed on
%low-level IR as the last step before leaving SSA form [39].  We use the
%second-chance binpacking variation of the linear scan register allocation
%algorithm [43, 47]. Our variant does not take Ï† nodes into account, so SSA
%form is destructed first by eliminating $\phi$ nodes while simultaneously
%performing copy coalescing, using the method described in [6].
