\section{Introduction}\label{sec:intro}

% CFGs, SSA form

Compilers translate programs written in a source language (e.g., Java) into
semantically equivalent programs in some target language (e.g., assembly code).
They let us make our source language arbitrarily abstract so we can write
programs in ways that humans understand while letting the computer execute
programs in ways that machines understand.  In a perfect world, such
translation would be straightforward.  Reality, however, is unforgiving.
Straightforward compilation results in clunky target code that performs a lot
of redundant computations.  To produce efficient code, we must rely on
less-than-straightforward methods.  Typical compilers go through a stage of
\term{optimization}, whereby a number of semantics-preserving transformations
are applied to an \term{intermediate representation} of the source code.  These
then (hopefully) produce a more efficient version of said representation.
Optimizers tend to work in \term{phases}, applying specific transformations
during any given phase.

\Gls{GVN} is such an analysis performed by many highly-optimizing compilers.
Its roots run deep through both the theoretical and the practical.  Using the
results of this analysis, the compiler can identify expressions in the source
code that produce the same value---not just by lexical comparison (i.e.,
variables having the same name), but by proving equivalences between what's
actually computed at runtime.  These expressions can then be simplified by
further algorithms for redundancy elimination.  This is the very essence of
most compiler optimizations: avoid redundant computation, giving us code that
runs as quickly as possible while still following what the programmer
originally wrote.

High-level, dynamic languages tend to suffer from efficiency issues: they're
often interpreted rather than compiled, and perform no heavy optimization of
the source code.  However, the Factor language (\url{http://factorcode.org})
fills an intriguing design niche, as it's very high-level yet still fully
compiled.  It's still young, though, so its compiler craves all the
improvements it can get.  In particular, while Factor currently has a
\term{local} value numbering analysis, it is inferior to \gls{GVN} in several
significant ways.

In this thesis, we explore the implementation and use of \gls{GVN} in improving
the strength of optimizations in Factor.  After establishing some preliminary
terminology and concepts in \cref{sec:intro:prelim}, we turn our attention to
the details.  Because Factor is a young and relatively unknown language,
\cref{sec:primer} provides an short tutorial, laying a foundation for
understanding the changes.  \Cref{sec:compiler} describes the overall
architecture of the Factor compiler, highlighting where the exact contributions
of this thesis fit in.  Finally, \cref{sec:vn} goes into detail about the
existing and new value numbering passes, closing with a look at the results
achieved and directions for future work.  In total, the following Factor
libraries were written for this thesis:
\begin{itemize}
  \item A \factor|graphviz| library, which provides bindings to create and
        manipulate graphs in Factor and output them using Graphviz
        (\url{http://graphviz.org}).
  \item The \factor|compiler.cfg.graphviz| library, which sues the Graphviz
        bindings to output images of Factor's low-level intermediate
        representation.  This is responsible for the illustrations of
        optimization passes seen in \cref{sec:vn}.
  \item The \factor|compiler.cfg.gvn| module, which was created by copying the
        existing value numbering code (from
        \factor|compiler.cfg.value-numbering|) to make the pass global.
\end{itemize}

All code was written atop Factor version $0.94$, and copies of it can be found
in the appendices.  In the unlikely event that you want to cite this thesis,
you may use the following \textsc{Bib}\TeX~entry:
\begin{center}
  \begin{Verbatim}[gobble=4,frame=single]
    @mastersthesis{vondrak:11,
      author = {Alex Vondrak},
      title  = {Global Value Numbering in Factor},
      school = {California Polytechnic State University, Pomona},
      month  = sep,
      year   = {2011},
    }
  \end{Verbatim}
\end{center}

%\subsection{Preliminaries}

%The most common intermediate representation (or at least the one we'll use
%here) is the \defn{control flow graph} (or \defn{CFG}, not to be confused with
%the abbreviation for ``context-free grammar'').  

%\begin{figure}
%  \begin{center}
%    \begin{minipage}{0.3\linewidth}
%      \begin{lstlisting}
%    i := 0
%    j := 0
%L1: i := i + 1
%    j := j + 1
%    if $P$ goto L1
%      \end{lstlisting}
%    \end{minipage}
%    \vrule
%    \begin{minipage}{0.3\linewidth}
%      \begin{tikzpicture}[node distance=.85in,>=latex]
%        \node[draw,label=right:$B_1$] (0) at (0,-1.25) {
%          \begin{lstlisting}
%i := 0
%j := 0
%          \end{lstlisting}
%        };
%        \node[draw,label=right:$B_2$] (1) [below of=0] {
%          \begin{lstlisting}
%i := i + 1
%j := j + 1
%if $P$ goto $B_2$
%          \end{lstlisting}
%        };
%
%        \draw[->] (0,0) -- (0);
%        \draw[->] (0) -- (1);
%        \draw (1.south)
%              edge[->,out=180,in=270,controls=+(35:-4) and +(-35:-4)]
%              (1.north);
%      \end{tikzpicture}
%    \end{minipage}
%  \end{center}
%  \caption{CFG Construction}
%  \label{fig:cfg-construction}
%\end{figure}
%
%For the purposes of this survey, we'll assume the compiler is transforming a
%simple three-address language, so-called because it's generally composed of
%instructions of the form \lstinline|x := y $op$ z|.  The semantics aren't
%terribly important, but the code should be clear to anyone familiar with basic
%assembly, as the language is modeled after common RISC machine code.  CFGs are
%arrangements of instructions into \defn{basic blocks}: maximal sequences of
%``straight-line'' code, where control does not transfer out of or into the
%middle of the block (e.g., by a \lstinline|goto|).  Then, directed edges are
%added between blocks to represent control flow---either from a \lstinline|goto|
%to its target, or from the end of a basic block to the start of the next one
%\cite{DragonBook}.  See Figure~\vref{fig:cfg-construction}.
%
%Probably the most popular intermediate representation in modern compilers is a
%variation of the CFG called \defn{static single assignment} (or \defn{SSA})
%form, wherein every variable in the program is defined by exactly one
%statement.  This simplifies the properties of variables, which helps
%optimizations perform faster and with better results.  The optimizations in
%this thesis will operate on SSA form.
%
%\begin{figure}
%\begin{center}
%  \begin{minipage}{0.4\linewidth}
%    \begin{tikzpicture}[node distance=1.0in,>=latex]
%    \node[draw,label=right:$B_1$] (1) at (0,-1.25)
%      {\lstinline|if $P$ goto $B_3$|};
%    \node[draw,label=left:$B_2$] (2) [below left of=1]
%      {\lstinline|x := 5|};
%    \node[draw,label=right:$B_3$] (3) [below right of=1]
%      {\lstinline|x := 10|};
%    \node[draw,label=right:$B_4$] (4) [below right of=2]
%      {\lstinline|y := x + 1|};
%
%    \draw[->] (0,0) -- (1);
%    \draw (1) edge[->] (2)
%              edge[->] (3)
%          (2) edge[->] (4)
%          (3) edge[->] (4);
%    \end{tikzpicture}
%  \end{minipage}
%  \vrule
%  \begin{minipage}{0.4\linewidth}
%    \begin{tikzpicture}[node distance=1.0in,>=latex]
%    \node[draw,label=right:$B_1$] (1) at (0,-1.25)
%      {\lstinline|if $P$ goto $B_3$|};
%    \node[draw,label=left:$B_2$] (2) [below left of=1]
%      {\lstinline|x$_0$ := 5|};
%    \node[draw,label=right:$B_3$] (3) [below right of=1]
%      {\lstinline|x$_1$ := 10|};
%    \node[draw,label=right:$B_4$] (4) [below right of=2]
%      {\lstinline|y$_{~}$ := x$_?$ + 1|};
%
%    \draw[->] (0,0) -- (1);
%    \draw (1) edge[->] (2)
%              edge[->] (3)
%          (2) edge[->] (4)
%          (3) edge[->] (4);
%    \end{tikzpicture}
%  \end{minipage}
%\end{center}
%\caption{SSA Construction Ambiguity}
%\label{fig:ssa-construction}
%\end{figure}
%
%At a high level, SSA form is constructed from a non-SSA CFG by giving unique
%names to the targets of each assignment (thus guaranteeing the SSA property),
%and by replacing uses of the original assignment with this new name.  But
%control flow can produce ambiguity.  In Figure~\vref{fig:ssa-construction}, the
%CFG on the left is being transformed into SSA form.  The original has two
%definitions of \lstinline|x| (in $B_2$ and $B_3$), either of which may reach
%the use of \lstinline|x| in $B_4$.  In SSA form, we give unique names to these
%two \lstinline|x| assignments, so which ``version'' do we use in $B_4$:
%\lstinline|x$_0$| or \lstinline|x$_1$|?
%
%\begin{figure}
%\begin{center}
%\begin{tikzpicture}[node distance=1.0in,>=latex]
%\node[draw,label=right:$B_1$] (1) at (0,-1.25) {\lstinline|if $P$ goto $B_3$|};
%\node[draw,label=left:$B_2$] (2) [below left of=1] {\lstinline|x$_0$ := 5|};
%\node[draw,label=right:$B_3$] (3) [below right of=1] {\lstinline|x$_1$ := 10|};
%\node[draw,label=right:$B_4$] (4) [below right of=2] {
%\begin{lstlisting}
%x$_2$ := $\phi$(x$_0$,x$_1$)
%y$_{~}$ := x$_2$ + 1
%\end{lstlisting}
%};
%
%\draw[->] (0,0) -- (1);
%\draw (1) edge[->] (2)
%          edge[->] (3)
%      (2) edge[->] (4)
%      (3) edge[->] (4);
%\end{tikzpicture}
%\end{center}
%\caption{$\phi$ Insertion}
%\label{fig:ssa-phi}
%\end{figure}
%
%To remedy this problem, SSA introduces a ``phony function'', $\phi$.  It's
%applied to two versions of variables that may reach the point where it's
%inserted.  While $\phi$ doesn't perform any literal computation, conceptually
%it selects the ``correct'' operand, depending on the control flow.  In
%Figure~\vref{fig:ssa-phi}, we correct the CFG of
%Figure~\ref{fig:ssa-construction} by inserting a new variable that's assigned
%to the result of the $\phi$ function and replacing the use of \lstinline|x|
%with this new variable.  Thus, if control flow goes $B_1 \to B_2 \to B_4$,
%$\phi$ selects \lstinline|x$_0$|.  If control flow goes $B_1 \to B_3 \to B_4$,
%$\phi$ selects \lstinline|x$_1$|.
%
%In principle, we could place any number of $\phi$-functions anywhere in the
%program (e.g., trivial ones like \lstinline|y := $\phi($x,x$)$|).  In practice,
%we insert them in as few places as possible---only at the beginnings of blocks
%where we need to.  There are many algorithms for efficient SSA construction
%with proper $\phi$ insertion (e.g., see \citeasnoun{SSAConstruction}) which are
%beyond the scope of this thesis.  For the rest of this proposal, it's assumed
%that CFGs are in SSA form.
