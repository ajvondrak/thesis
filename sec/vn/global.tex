\subsection{Global Value Numbering}\label{sec:vn:global}

Answering the challenges of Cocke\todo{cite-like}, AWZ~\todo{cite-like}
described what would be the de facto value numbering algorithm for several
years, and rightly so.  It was a properly \term{global} value numbering
algorithm, working across an entire \gls{CFG} instead of on single basic
blocks.  Their paper was important in another very relevant way: it is the
first published reference to SSA form\todo{cite VanDrunen}, including an
algorithm for its construction.

Though we could try to extend the scope of Factor's local value numbering, it
is still inherently pessimistic.  The algorithm of AWZ\todo{cite-like}, which
is commonly referred to simply as AWZ\todo{gls?}, uses a modification of
Hopcroft's~\todo{cite-like} minimization algorithm for finite state automata.
It works on an \term{optimistic} assumption by first assuming every value has
the same value number, then trying to prove that values are actually different.
It does this by treating value numbers as \term{congruence classes} that
partition the set of virtual registers.  If two values are in the same class,
then they are congruent, where congruence is defined as in \cref{sec:vn:local}.

Such a partition is not unique, in general.  For instance, a trivial one places
each value in its own congruence class.  So, we look for the \term{maximal
fixed point}---the solution that has the most congruent values and therefore
the fewest congruence classes.  We must start with a congruence class for each
operation so that, say, all values computed by \factor|##add|s are grouped
together, those computed by \factor|##mul|s are in the same class, etc.  We
must then iteratively look at our collection of classes, separating them when
we discover incongruent values.  For an \gls{SSA} variable in class $P$, we
look at its defining expression.  If an operand at position $i$ belongs to
class $Q$, then the $i^\text{th}$ operand of every other value in $P$ should
also be in $Q$.  Otherwise, $P$ must be \term{split} by removing those
variables whose $i^\text{th}$ operands are not in class $Q$ and placing them in
a new congruence class.  We keep splitting classes until the partitioning
stabilizes.

The optimistic assumption may seem dangerous.  Is it possible that we're
``overoptimistic''?  That two values assumed to be congruent and not proven
incongruent might actually be inequivalent when the program is run?  The
AWZ~\todo{gls?} paper dedicates a section to proving that two congruent
variables are equivalent at a point $p$ in the program if their definitions
dominate $p$.  The proof is a bit quirky, but reasonable.  They develop a
dynamic notion of dominance in a running program which implies static dominance
in the code, then show that congruence implies runtime equality (though
equivalence does not imply congruence).

AWZ\todo{gls?}~ made the need for \gls{GVN} algorithms apparent.  However,
finite state automata minimization makes for a more complicated algorithm than
hash-based value numbering.  A na\"{i}ve implementation can be quadratic,
although careful data structure and procedure design can make it $O(n\log n)$.
Furthermore, it's resistant to the same improvements we easily added to the
local value numbering.  To even consider the commutativity of operations
requires changes in operand position tracking and splitting---the heart of the
algorithm.  It is generally limited by what the programmer writes down: deeper
congruences due to, say, algebraic identities can't be discovered.

In fact, by performing an optimization that uses the \gls{GVN} information,
more \gls{GVN} congruences may arise.  If we can somehow perform the two
analyses simultaneously, they'll produce better results.  This generalizes to
interdependent compiler optimizations at large, as elucidated in
Click's\todo{cite-like}~ dissertation, which describes a method for formalizing
and combining separate optimizations that make optimistic assumptions (whatever
they happen to be for each particular analysis).  He uses this to merge
\gls{GVN} with \term{conditional constant propagation}, which itself is a
combination of constant propagation and unreachable code elimination (pretty
much like the \factor|propagate| pass from \cref{sec:compiler:tree}).
Furthermore, \gls{GVN} is extended to handle algebraic identities, propagate
constants, and fold redundant $\phi$s.  Unfortunately, the straightforward
algorithm for this is $O(n^2)$, while the $O(n\log n)$ version presented is not
just complicated, but can also miss some congruences between
$\phi$-functions\todo{cite Click, Simpson}.

Hot on the heels of this work, Simpson's\todo{cite-like}~ dissertation provides
probably the most exhaustive treatment of \gls{GVN} algorithms.  He presents
several extensions, such as incorporating hash-based local value numbering into
\gls{SSA} construction, handling commutativity in AWZ\todo{gls?}~ \gls{GVN},
and performing redundant store elimination.  He builds off of the two classical
algorithms independently, which underlines their inherent differences and
limitations.  In general, hash-based value numbering is easy to extend without
greatly impacting the runtime complexity, as is the case in Factor's
implementation.

Drawing from this experience, Simpson's hallmark algorithm combines the best of
both worlds by taking the hash-based algorithm which is easy to understand,
implement, and extend, and making it global, so it identifies more congruences.
Dubbed the ``\gls{RPO} algorithm'', it simply applies hash-based value
numbering iteratively over the \gls{CFG} until we reach the same fixed point
computed by AWZ\todo{gls?}.  (The fact that it computes the \emph{same} fixed
point is proven fairly straightforwardly in the dissertation.)  It could
technically traverse the \gls{CFG} in any topological order, but Simpson
defaults to reverse postorder.

Because it is based off the hashing algorithm, we get the benefits essentially
for free.  The same simplifications can be performed, but with the added
knowledge of global congruences.  Since the majority of Factor's value
numbering code is dedicated to the \factor|rewrite| generic, it makes sense to
reuse as much of that code as possible.  Therefore, to convert Factor's local
algorithm to a global one, I modified the existing code to use the \gls{RPO}
algorithm.

\inputlst{gvn-graph}

The most fundamental change is to the expression graph.  Referring to
\vref{lst:gvn-graph}, we see most of the same code as in
\vref{lst:value-numbering-graph}, with changes indicated by arrows
($\longrightarrow$).  Two more global variables have been added, namely
\factor|changed?| and \factor|final-iteration?|.  The former is what we use to
guide the fixed-point iteration.  As long as value numbers are changing, we
keep iterating.  An important side effect of this is that we can no longer
perform \factor|rewrite| online, since the transformations we make aren't
guaranteed to be sound on any iteration except the final one.  This makes the
\gls{RPO} algorithm work \term{offline}, first discovering redundancies, then
eliminating them in a separate pass.  When this elimination pass starts, we'll
set \factor|final-iteration?| to \factor|t|.

A key change is in the \factor|vreg>vn| word, which now makes an optimistic
assumption about previously unseen values.  Given a new virtual register that
wasn't in the \factor|vregs>vns| table, the old version would map the register
to itself, making the value its own canonical representative.  However, if this
version tries to look up a key that does not exist in the hash table, it will
simply return \factor|f| (which Factor will do by default with the \factor|at|
word).  Therefore, every value in the \gls{CFG} starts off with the same value
``number'', \factor|f|.  By the end of the \gls{GVN} pass, there should be no
value left that hasn't been put in the \factor|vregs>vns| table, as we'll have
processed every definition.

To keep track of whether \factor|vregs>vns| changes, we simply need to alter
\factor|set-vn|.  Here, we use \factor|maybe-set-at|, a utility from the
\factor|assocs| vocabulary.  This works like \factor|set-at|, establishing a
mapping in the hash table.  In addition, it returns a boolean indicating
change: if a new key has been added to the table, we return \factor|t|.
Otherwise, we return \factor|t| only in the case where an old key is mapped to
a new value.  If an old key is mapped to the same value that's already in the
table, \factor|maybe-set-at| returns \factor|f|.  Therefore, when
\factor|vregs>vns| does change, we set \factor|changed?| to \factor|t| (which
is what the \factor|on| word does).

Finally, we define a new utility word, \factor|clear-exprs|, which resets the
\factor|exprs>vns| and \factor|vns>insns| tables.  Unlike the local value
numbering phase, we don't reset the entire expression graph.  Instead, we make
a pass over the whole \gls{CFG} at a time.  The only reason optimism works is
that we keep trying to disprove our foolhardy assumptions.  Really,
\factor|vregs>vns| establishes congruence classes of value numbers.  At first,
every value belongs in one class, \factor|f|.  We make a pass over the
\gls{CFG} to disprove whatever we can about this.  If we've introduced new
congruence classes (new values in the \factor|vregs>vns| hash), we do another
iteration.  But each time, we use the congruence classes discovered from the
previous iteration.  At the start of each new pass, the expressions and
instructions in \factor|exprs>vns| and \factor|vns>insns| are
invalidated---their results are based on old information.  So, these are erased
on each iteration.  Much like AWZ\todo{gls?}, we keep splitting classes until
they can't be split anymore.

\inputlst{gvn-step}

This logic is captured in \vref{lst:gvn-step}.  Rather than reset the tables
when we start processing each basic block in \factor|value-numbering-step| like
before, we call \factor|clear-exprs| on each iteration over the \gls{CFG} in
\factor|value-numbering-iteration|.  Note that \factor|value-numbering-step| no
longer returns the changed instructions, as we aren't replacing them online.
\factor|value-numbering-iteration| uses \factor|simple-analysis| instead of
\factor|simple-optimization|, which only expects global state to change---no
instructions are updated in the block.  Much to our advantage,
\factor|simple-analysis| already traverses the \gls{CFG} in \acrlong{RPO}, so
we needn't worry about traversal order.  The top-level word
\factor|determine-value-numbers| ties this all together by calling
\factor|value-numbering-iteration| until we can get through it with
\factor|changed?| remaining false.

\inputlst{gvn-simplify}
\inputlst{gvn-value-number}

Note that the work of \factor|value-numbering-step| is further divided into two
words, \factor|simplify| and \factor|value-number|.  These combine to do much
the same work as \factor|process-instruction| in
\vref{lst:process-instruction}.  \factor|simplify| makes the repeated calls to
\factor|rewrite| until the instruction cannot be simplified further.  Its
definition is in \vref{lst:gvn-simplify}.  We then pass the simplified
instruction to \factor|value-number|, which is defined in
\vref{lst:gvn-value-number}.  This also has a similar structure to
\factor|process-instruction|.  The main difference is that instructions are no
longer returned (again, they aren't altered in place).  So, the \factor|array|
method uses \factor|each| instead of \factor|map| to recurse into the results
of \factor|rewrite|.

A subtle change is necessary with the \factor|alien-call-insn| and
\factor|##callback-inputs| methods.  Whereas \factor|process-instruction|
merely skipped over certain instructions that could not be rewritten, here we
don't have that luxury.  We need to be careful to \factor|set-vn| every virtual
register that gets defined by any instruction.  While making a pessimistic
assumption, it didn't matter if we did this: any unseen value would be presumed
important by \factor|vreg>vn|.  However, with the optimistic assumption,
\factor|vreg>vn| will give the impression that unseen values are all the same
by returning \factor|f|.  Therefore, we simply record the virtual registers
defined in instructions that may define one or more of them.  Specifically,
\factor|alien-call-insn| and \factor|##callback-inputs| are classes that
correspond to \gls{FFI} instructions.

The \factor|##copy| method uses \factor|set-vn| the same way as before.
\factor|redundant-instruction|, \factor|useful-instruction|, and
\factor|check-redundancy| are also largely the same.  These have just been
tweaked to not return instructions.

\inputlst{phi-expr}

The \factor|##phi| method in \vref{lst:gvn-value-number} represents a major
change. Before, \factor|##phi|s were left uninterpreted.  Congruences between
induction variables that flowed along back-edges would not be identifiable.
But now, by checking for redundant \factor|##phi|s, we may reduce them to
copies.  Each \factor|##phi| object has an \factor|inputs| slot, which is a
hash table from basic block to the virtual register that flows from that block.
Thus, there is one input for each predecessor.  The \factor|values| of the hash
will be the virtual registers that might be selected for the \factor|dst|
value.  We look up the value numbers of these, removing all instances of
\factor|f| with the \factor|sift| word.  If all of the inputs are congruent, we
can call \factor|redundant-instruction|, setting the value number of the
\factor|##phi|'s \factor|dst| to the value number of its first input (without
loss of generality).  The \factor|all-equal?| word will return \factor|t| if
the sequence is empty (as it's vacuously true), so we must make sure not to
call \factor|first| on the sequence, since this will be a runtime error.  If
the sequence is empty, we needn't note the redundancy, as the \factor|##phi|'s
\factor|dst| will already have the optimistic value number \factor|f| anyway.
Otherwise, we call \factor|check-redundancy|.  The purpose of this is to
identify \factor|##phi|s that are equal to each other.  Even if its inputs are
incongruent, a \factor|##phi| might still represent a copy of another induction
variable.  So that \factor|check-redundancy| works, we also define a
\factor|>expr| method in \factor|compiler.cfg.gvn.expressions|, as seen in
\vref{lst:phi-expr}.  Here, the expression is an array consisting of the
\factor|##phi| class word, the current basic block's number, and the inputs'
value numbers.  We include the basic block number because only \factor|##phi|s
within the same block can be considered equivalent to each other.

The final method in \vref{lst:gvn-value-number} defines the default behavior
for \factor|value-number|, which calls \factor|check-redundancy| on the
simplified instruction if it defines a single virtual register.  Note that we
separate the \factor|alien-call-insn| and \factor|##callback-inputs| logic from
this, since they happen to define a variable number of registers.  If
particular instances define only one register, we still don't want to call
\factor|check-redundancy| on them, since they don't have a \factor|dst| slot.
To avoid calling \factor|dst>>| and triggering an error in
\factor|useful-instruction|, we needed separate methods for the \gls{FFI}
classes.

\inputfig{gvn}

With these changes, we can globally identify value numbers, including
equivalences that arise from simplifying instructions (even though no
replacements are actually done yet).  To illustrate this, consider again the
example
%
\factor|0 100 [ 1 fixnum+fast ] times|,
%
reproduced in \vref{fig:gvn}.  As the expression graph changes frequently in
this new algorithm, instead of showing the literal hash tables we'll use a
shorthand notation.  Virtual registers will be integers, and to avoid confusion
value numbers will be written in brackets, like \vn{n}.  Then, we'll show
\factor|vreg>vn| mappings with the notation $n\to\vn{n}$, where $n$ is the
register and \vn{n} is the value number.  If there is a corresponding
expression in \factor|exprs>vns|, it will be denoted after the mapping, like
$n\to\vn{n}~(\textit{expression})$.  With the expressions, the instructions in
\factor|vns>insns| are a bit redundant for understanding the value numbering
process, so they will be elided.  Any mappings to \factor|f| will be elided, as
they're understood to be implicit when a key is absent.

\todo[inline]{Might make separate figures of each block, for easier reference}

\factor|determine-value-numbers| starts the first iteration, which of course
starts at basic block $1$.  \factor|##inc-d| is a no-op, but the first two
\factor|##load-integer|s are established as useful instructions.
%
\factor|##load-integer 23 0|
%
is recognized as redundant, since at this point we know that \factor|21| has
the value \factor|0|.  The \factor|##copy| instructions all pile on value
number mappings, leaving us with the following:
%
\begin{align*}
  21 &\to \vn{21} \quad (0)  \\
  22 &\to \vn{22} \quad (100)\\
  23 &\to \vn{21}            \\
  24 &\to \vn{22}            \\
  25 &\to \vn{21}            \\
  26 &\to \vn{22}            \\
  27 &\to \vn{21}
\end{align*}

At iteration $1$, basic block $2$, the first \factor|##phi| has inputs
\factor|25| (from block $1$) and \factor|41| (from block $3$).  The former has
the value number \vn{21}, while the latter is still at \factor|f|.  We treat
this value number much like a $\top$ element, unifying it with the other input
to give us the assumption that \factor|29| will be a copy of \factor|25|.
Thus, it gets the same value number.  A similar choice happens for the second
\factor|##phi|.  The instruction 
%
\factor|##compare-integer 31 30 26 cc< 9|
%
is an interesting case.  Due to our optimistic assumptions thus far, we believe
\factor|30| is carrying the value \factor|0|, and that \factor|26| is set to
\factor|100|.  Thus, this instruction gets constant-folded by \factor|simplify|
into
%
\factor|##load-reference 31 t|.
%
The \gls{CFG} isn't changed, but the expression graph reflects this belief.
Later, this assumption will be invalidated.  The following copies are processed
as usual, with the distinct difference here that 
%
\factor|##copy 33 26 any-rep|
%
has the global knowledge of the value number of \factor|26|.  Because the
\factor|##compare-integer| was constant-folded, so is the
\factor|##compare-imm-branch|---and to the same value, no less.  This leaves us
with:
%
\begin{align*}
  21 &\to \vn{21} \quad (0)                 \\
  22 &\to \vn{22} \quad (100)               \\
  23 &\to \vn{21}                           \\
  24 &\to \vn{22}                           \\
  25 &\to \vn{21}                           \\
  26 &\to \vn{22}                           \\
  27 &\to \vn{21}                           \\
  29 &\to \vn{21}                           \\
  30 &\to \vn{21}                           \\
  31 &\to \vn{31} \quad (\text{\factor|t|}) \\
  32 &\to \vn{31}                           \\
  33 &\to \vn{22}                           \\
  34 &\to \vn{31}
\end{align*}

Block $3$ of iteration $1$ gives the \factor|##load-integer|s' destinations the
same value number, corresponding to the integer $1$.  Because optimism makes
the algorithm think that \factor|29| and \factor|30| correspond to the integer
$0$, the \factor|##add|s are constant-folded.  This leaves us with:
%
\begin{align*}
  21 &\to \vn{21} \quad (0)                 \\
  22 &\to \vn{22} \quad (100)               \\
  23 &\to \vn{21}                           \\
  24 &\to \vn{22}                           \\
  25 &\to \vn{21}                           \\
  26 &\to \vn{22}                           \\
  27 &\to \vn{21}                           \\
  29 &\to \vn{21}                           \\
  30 &\to \vn{21}                           \\
  31 &\to \vn{31} \quad (\text{\factor|t|}) \\
  32 &\to \vn{31}                           \\
  33 &\to \vn{22}                           \\
  34 &\to \vn{31}                           \\
  35 &\to \vn{35} \quad (1)                 \\
  36 &\to \vn{35}                           \\
  37 &\to \vn{35}                           \\
  38 &\to \vn{35}                           \\
  39 &\to \vn{21}                           \\
  40 &\to \vn{22}                           \\
  41 &\to \vn{35}                           \\
  42 &\to \vn{35}
\end{align*}

While block $4$ is visited in each iteration, it doesn't define any registers,
so doesn't affect the state of value numbering.  Therefore, the above is the
state left at the end of iteration $1$.

Since \factor|vregs>vns| clearly changed, iteration $2$ commences by clearing
the expressions, though the value numbers remain.  Block $1$ doesn't change
from iteration $1$, giving us:
%
\begin{align*}
  21 &\to \vn{21} \quad (0)                 \\
  22 &\to \vn{22} \quad (100)               \\
  23 &\to \vn{21}                           \\
  24 &\to \vn{22}                           \\
  25 &\to \vn{21}                           \\
  26 &\to \vn{22}                           \\
  27 &\to \vn{21}                           \\
  29 &\to \vn{21}                           \\
  30 &\to \vn{21}                           \\
  31 &\to \vn{31}                           \\
  32 &\to \vn{31}                           \\
  33 &\to \vn{22}                           \\
  34 &\to \vn{31}                           \\
  35 &\to \vn{35}                           \\
  36 &\to \vn{35}                           \\
  37 &\to \vn{35}                           \\
  38 &\to \vn{35}                           \\
  39 &\to \vn{21}                           \\
  40 &\to \vn{22}                           \\
  41 &\to \vn{35}                           \\
  42 &\to \vn{35}
\end{align*}

Now that we're in iteration $2$, the inputs to the \factor|##phi|s of block $2$
have been processed once before.  For instance, we still believe that
\factor|25| corresponds to the integer $0$ (which is incidentally correct), but
now that \factor|41| has the value number \vn{35}, we think it corresponds to
the integer $1$.  While this is incorrect, it does break the congruence between
the inputs, making the first \factor|##phi| a useful instruction.  The second
\factor|##phi|, however, still looks like a copy of the first.  Even so, this
is sufficiently different that the following \factor|##compare-integer| cannot
be constant-folded like before.  However, it can still be converted to a
\factor|##compare-integer-imm|, as one of its operands corresponds to an
integer.  The redundant \factor|##compare-imm-branch| gets rewritten to the
same expression as the \factor|##compare-integer|, so winds up getting the same
value number.  This gives us:
%
\begin{align*}
  21 &\to \vn{21} \quad (0)                                                \\
  22 &\to \vn{22} \quad (100)                                              \\
  23 &\to \vn{21}                                                          \\
  24 &\to \vn{22}                                                          \\
  25 &\to \vn{21}                                                          \\
  26 &\to \vn{22}                                                          \\
  27 &\to \vn{21}                                                          \\
  29 &\to \vn{29} \quad (\text{\factor|##phi 2 21 35|})                    \\
  30 &\to \vn{29}                                                          \\
  31 &\to \vn{31} \quad (\text{\factor|##compare-integer-imm 29 100 cc<|}) \\
  32 &\to \vn{31}                                                          \\
  33 &\to \vn{22}                                                          \\
  34 &\to \vn{31}                                                          \\
  35 &\to \vn{35}                                                          \\
  36 &\to \vn{35}                                                          \\
  37 &\to \vn{35}                                                          \\
  38 &\to \vn{35}                                                          \\
  39 &\to \vn{21}                                                          \\
  40 &\to \vn{22}                                                          \\
  41 &\to \vn{35}                                                          \\
  42 &\to \vn{35}
\end{align*}

Block $3$ of iteration $2$ also changes, since the \factor|##add|s can't be
constant-folded like before due to our new discovery about the \factor|##phi|s.
However, the first one can still be converted to an \factor|##add-imm|, and the
second is marked the same as the first.  This leaves the following value
numbers:
%
\begin{align*}
  21 &\to \vn{21} \quad (0)                                                \\
  22 &\to \vn{22} \quad (100)                                              \\
  23 &\to \vn{21}                                                          \\
  24 &\to \vn{22}                                                          \\
  25 &\to \vn{21}                                                          \\
  26 &\to \vn{22}                                                          \\
  27 &\to \vn{21}                                                          \\
  29 &\to \vn{29} \quad (\text{\factor|##phi 2 21 35|})                    \\
  30 &\to \vn{29}                                                          \\
  31 &\to \vn{31} \quad (\text{\factor|##compare-integer-imm 29 100 cc<|}) \\
  32 &\to \vn{31}                                                          \\
  33 &\to \vn{22}                                                          \\
  34 &\to \vn{31}                                                          \\
  35 &\to \vn{35} \quad (1)                                                \\
  36 &\to \vn{36} \quad (\text{\factor|##add-imm 29 1|})                   \\
  37 &\to \vn{35}                                                          \\
  38 &\to \vn{36}                                                          \\
  39 &\to \vn{29}                                                          \\
  40 &\to \vn{22}                                                          \\
  41 &\to \vn{36}                                                          \\
  42 &\to \vn{36}
\end{align*}

Since the value numbers changed, we start iteration $3$.  The expressions are
cleared, and block $1$ once again does not change anything.  The first
\factor|##phi| in block $2$ still gets classified as useful, so no value
numbers change.  The major difference, though, is that the previous iteration's
value numbers for registers in block $3$ update the expression we have for the
\factor|##phi|.  Whereas before we thought it was choosing between \vn{21} (the
integer $0$) and \vn{35} (the integer $1$), the \factor|##add| wasn't
constant-folded in the previous iteration.  Therefore, the virtual register
\factor|41| now corresponds to the result of the \factor|##add| with the value
number \vn{36}.  We still can't disprove that the second \factor|##phi| is
different (because it, in fact, isn't).  So, we're left with the following
after iteration $3$ finishes with block $2$:
%
\begin{align*}
  21 &\to \vn{21} \quad (0)                                                \\
  22 &\to \vn{22} \quad (100)                                              \\
  23 &\to \vn{21}                                                          \\
  24 &\to \vn{22}                                                          \\
  25 &\to \vn{21}                                                          \\
  26 &\to \vn{22}                                                          \\
  27 &\to \vn{21}                                                          \\
  29 &\to \vn{29} \quad (\text{\factor|##phi 2 21 36|})                    \\
  30 &\to \vn{29}                                                          \\
  31 &\to \vn{31} \quad (\text{\factor|##compare-integer-imm 29 100 cc<|}) \\
  32 &\to \vn{31}                                                          \\
  33 &\to \vn{22}                                                          \\
  34 &\to \vn{31}                                                          \\
  35 &\to \vn{35}                                                          \\
  36 &\to \vn{36}                                                          \\
  37 &\to \vn{35}                                                          \\
  38 &\to \vn{36}                                                          \\
  39 &\to \vn{29}                                                          \\
  40 &\to \vn{22}                                                          \\
  41 &\to \vn{36}                                                          \\
  42 &\to \vn{36}
\end{align*}

Blocks $3$ and $4$ do not produce any more changes, so \gls{GVN} has stabilized
after $3$ iterations, with our final congruence classes being:
%
\begin{align*}
  \vn{21} &= \{21, 23, 25, 27\}     \\
  \vn{22} &= \{22, 24, 26, 33, 40\} \\
  \vn{29} &= \{29, 30, 39\}         \\
  \vn{31} &= \{31, 32, 34\}         \\
  \vn{35} &= \{35, 37\}             \\
  \vn{36} &= \{36, 38, 41, 42\}
\end{align*}

\todo[inline]{teletype the numbers in the align*s, I guess}
