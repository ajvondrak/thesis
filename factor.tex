\section{Language Primer}

\todo[inline]{citations for this history are fragmented across the internet;
should consolidate some kernel of citation from it}

Factor is a rather young language created by Slava Pestov in September of 2003.
Its first incarnation targeted the \gls{JVM} as an embedded scripting language
for a game.  As such, its feature set was minimal.  Factor has since evolved
into a general-purpose programming language, gaining new features and
redesigning old ones as necessary for larger programs.  Today's implementation
sports an extensive standard library and has moved away from the \gls{JVM} in
favor of native code generation.  In this section\todo{figure out section /
chapter names}, we cover the basic syntax and semantics of Factor for those
unfamiliar with the language.  This should be just enough to understand the
later material in this thesis\todo{cite chapter?}.  More thorough documentation
can be found via Factor's website\todo{cite factorcode.org}.

\subsection{Stack-Based Programming}

\inputfig{rpn}

Like \gls{RPN} calculators, Factor's essential evaluation model uses a global
\term{stack} upon which operands are pushed before operators are called.  This
lends itself to \term{postfix} notation, in which operators are written after
their operands.  For example, instead of \texttt{1~+~2}, we write
\texttt{1~2~+}.  \Vref{fig:rpn} shows how \texttt{1~2~+} works conceptually:
\begin{itemize}
  \item \texttt{1} is pushed onto the stack
  \item \texttt{2} is pushed onto the stack
  \item \texttt{+} is called, so two values are popped from the stack, added,
        and the result (\texttt{3}) is pushed back onto the stack
\end{itemize}
Other stack-based programming languages include Forth\todo{cite},
Joy\todo{cite}, Cat\todo{cite}, and PostScript\todo{cite}.

The strength of this model is its simplicity.  For instance, parsing is made
very flexible, since whitespace is essentially the only thing that separates
tokens.  In the Forth tradition, functions (being single tokens delineated by
whitespace) are called \term{words}.  This also lends to the term
\term{vocabulary} instead of ``module'' or ``library''.  In Factor, the parser
works as follows.
\begin{itemize}
  \item If the current character is a double-quote (\lstinline|"|), try to
        parse a string literal.
  \item Otherwise, scan ahead for a single token.
        \begin{itemize}
          \item If the token is the name of an \term{ordinary word}, it's added
                to the parse tree.
          \item If the token is the name of a \term{parsing word}, it's invoked
                with the parser's current information.
          \item Otherwise, try to parse the token as a numeric literal.
        \end{itemize}
\end{itemize}

\begin{itemize}

\item Basic syntax \& semantics
      \begin{itemize}
        \item Parsing algorithm
              \begin{itemize}
                \item \verb|"|
                \item token
                      \begin{itemize}
                        \item ordinary word (terminology, incl. ``vocabulary'')
                        \item parsing word
                      \end{itemize}
                \item number
              \end{itemize}
        \item Example ordinary words: stack shufflers
        \item Example parsing words: quotations
      \end{itemize}

\item Concatenative programming
      \begin{itemize}
        \item ``Pipeline code''
        \item Whitespace = function composition
        \item Point-free style
        \item Origin of name ``Factor''
      \end{itemize}

\item Stack effects
      \begin{itemize}
        \item Basic stack effects: stack shufflers illustrated
        \item Complex stack effects: row polymorphism \& types
        \item Stack checker
      \end{itemize}

\item Control flow
      \begin{itemize}
        \item Combinators
              \begin{itemize}
                \item if
                \item each
                \item while
              \end{itemize}
        \item Dataflow combinators
              \begin{itemize}
                \item Dip/keep
                \item Cleave
                \item Spread
                \item Apply
              \end{itemize}
      \end{itemize}

\item Object system
      \begin{itemize}
        \item tuples
        \item generics \& methods
      \end{itemize}

\item Libraries \& metaprogramming
      \begin{itemize}
        \item Results of evolution
        \item locals?
        \item fry?
        \item macros?
        \item functors?
        \item ffi?
      \end{itemize}

\end{itemize}

\end{document}
