\section{Language Primer}\label{sec:primer}

\todo[inline]{citations for this history are fragmented across the internet;
should consolidate some kernel of citation from it}

Factor is a rather young language created by Slava Pestov in September of 2003.
Its first incarnation targeted the \gls{JVM} as an embedded scripting language
for a game.  As such, its feature set was minimal.  Factor has since evolved
into a general-purpose programming language, gaining new features and
redesigning old ones as necessary for larger programs.  Today's implementation
sports an extensive standard library and has moved away from the \gls{JVM} in
favor of native code generation.  In this \lcnamecref{sec:primer}, we cover the
basic syntax and semantics of Factor for those unfamiliar with the language.
This should be just enough to understand the later material in this thesis.
More thorough documentation can be found via Factor's website,
\url{http://factorcode.org}.

\subsection{Stack-Based Languages}\label{sec:primer:stack-based}

\inputfig{rpn}

Like \gls{RPN} calculators, Factor's evaluation model uses a global stack upon
which operands are pushed before operators are called.  This naturally
facilitates \term{postfix} notation, in which operators are written after their
operands.  For example, instead of \texttt{1~+~2}, we write \texttt{1~2~+}.
\Vref{fig:rpn} shows how \texttt{1~2~+} works conceptually:
\begin{itemize}
  \item \texttt{1} is pushed onto the stack
  \item \texttt{2} is pushed onto the stack
  \item \texttt{+} is called, so two values are popped from the stack, added,
        and the result (\texttt{3}) is pushed back onto the stack
\end{itemize}
Other stack-based programming languages include Forth\todo{cite},
Joy\todo{cite}, Cat\todo{cite}, and PostScript\todo{cite}.

The strength of this model is its simplicity.  Evaluation essentially goes
left-to-right: literals (like \texttt{1} and \texttt{2}) are pushed onto the
stack, and operators (like \texttt{+}) perform some computation using values
currently on the stack.  Parsing becomes very flexible, since whitespace is
basically the only thing that separates tokens\todo{not the reason}.  In the
Forth tradition, functions (being single tokens delineated by whitespace) are
called \term{words}.  This also lends to the term \term{vocabulary} instead of
``module'' or ``library''.   In Factor, the parser works as follows.
\begin{itemize}
  \item If the current character is a double-quote (\texttt{"}), try to
        parse ahead for a string literal.
  \item Otherwise, scan ahead for a single token.
        \begin{itemize}
          \item If the token is the name of a \term{parsing word}, that word is
                invoked with the parser's current state.
          \item If the token is the name of an ordinary (i.e., non-parsing)
                word, that word is added to the parse tree.
          \item Otherwise, try to parse the token as a numeric literal.
        \end{itemize}
\end{itemize}

Parsing words serve as hooks into the parser, letting Factor users extend the
syntax dynamically.  For instance, instead of having special knowledge of
comments built into the parser, the parsing word \texttt{!}~makes the parser
scan forward for a newline and discard any characters read (adding nothing to
the parse tree).

Similarly, there are parsing words for what might otherwise be hard-coded
syntax for data structure literals.  Many act as sided delimeters: the parsing
word for the left-delimiter will parse ahead until it reaches the
right-delimiter, using whatever was read in between to add objects to the data
structure.  For example, \factor|{ 1 2 3 }| denotes an array of three numbers.
Note the deliberate spaces in between the tokens, so that the delimeters are
themselves distinct words.  In
%
\Verb[showspaces]|{ 1 2 3 }| (with spaces as marked), the parsing word \Verb|{|
parses objects until it reaches \Verb|}|, collecting the results into an array.
The \verb|{| word would not be called if not for that space, whereas
%
\Verb[showspaces]|{1 2 3}| parses as the word \Verb|{1|, the number \Verb|2|,
and the word \Verb|3}|---not an array.  Further, since the left-delimeter words
parse recursively, sequence literals can be nested, contain comments, etc.
Other literals include \vpageref[the following][those in
\cref{lst:seq}~]{lst:seq}.

\inputlst[h]{seq}

%Words correspond to \term{first-class} functions from other languages.  That
%is, words are themselves objects that just perform instructions whenever
%they're told---most commonly, when Factor is executing a piece of code.  While
%infix languages tend to distinguish syntactically significant operators (e.g.,
%for arithmetic) from normal user-defined functions, there is no such difference
%here.  Since \factor|1 2 +| and \factor|1 2 foo| are tokenized the same
%way, other languages' special operators are just words in Factor.

\inputfig{quot}

A particularly important set of parsing words in Factor are the square
brackets, \Verb|[| and \Verb|]|.  Any code in between such brackets is
collected up into a special sequence called a \term{quotation}.  Essentially,
it's a snippet of code whose execution is suppressed.  The code inside a
quotation can then be run with the \factor|call| word.  Quotations are like
anonymous functions in other languages, but the stack model makes them
conceptually simpler, since we don't have to worry about variable binding and
the like.  Consider a small example like \factor|1 2 [ + ] call|.  You can
think of \factor|call| working by ``erasing'' the brackets around a quotation,
so this example behaves just like \factor|1 2 +|.  \Vref{fig:quot} shows its
evaluation: instead of adding the numbers immediately, \factor|+| is placed in
a quotation, which is pushed to the stack.  The quotation is then invoked by
\factor|call|, so \factor|+| pops and adds the two numbers and pushes the
result onto the stack.  We'll show how quotations are used in
\cref{sec:primer:control-flow}.

%\subsection{Control Flow}\label{sec:primer:control-flow}

\subsection{Concatenative Programming}

The biggest step needed to understand Factor isn't really big: everything else
follows from the stack-based structure outlined in
\cref{sec:primer:stack-based}.  With some input on the stack, consecutive words
transform the data in discrete steps, thereby shaping a result.  This breeds a
fairly stylized way of writing code that resembles a pipeline.  Postfix code
like \factor|1 2 +| often seems to read ``backwards'', but when viewed in
this pipelined fashion, it can read more clearly than standard syntax.  For
instance, suppose we're given a value \factor|x| to manipulate by applying
three functions, \factor|f|, \factor|g|, and \factor|h|, in order.
Typical function application notation looks like \texttt{h(g(f(x)))}, which
must be read from the inside out because of the nested function calls.  In
Factor, we'd write \factor|x f g h|, which is flat and reads left-to-right.
Having such a whitespace-centered syntax reduces noise: instead of grouping
arguments, the order of evaluation is the order you write your code.

In a way, this makes whitespace equivalent to function composition: just treat
every word as a function from stacks to stacks---``before'' to ``after''.  Even
literals (numbers, strings, etc.) can be thought of as functions that take in a
stack and return that stack with an extra element pushed onto it.  Since
concatenating any two programs denotes the composition of the functions that
the programs individually denote, Factor is said to be a \term{concatenative}
language\todo{cite and talk about Joy}.  Note that being stack-based is
unnecessary for being concatenative, though it's common\todo{list other
concatenative languages}.

This functional interpretation is useful for formally reasoning about
concatenative languages\todo{cite Joy}, but it also highlights how Factor
parallels more traditional functional languages.  In particular, languages like
Haskell encourage \term{point-free style}, wherein calculations are performed
using function composition rather than application\todo{cite}.  Using this
idiom, code is more compact and references fewer variables (the ``points'' of
point-free style).  Since data is passed around the stack in Factor, there's no
need for variables---point-free style is the default.  In the absence of named
values, new operators spring up to name different patterns in code.  These make
data flow explicit, since you can't use intermediate variables or tricks of
syntax as a crutch.  Such operators are discussed in
\cref{sec:primer:dataflow}.

Taken together, concatenative idioms emphasize shorter, clearer code.  Since
data flow is explicit, complicated patterns become painfully evident.  There's
little syntactic noise, so repetitive bits of code are easily recognized.
Because whitespace is composition, these complicated, repetitive sections of
code are easily ``factored'' (extracted) into new word definitions, hence the
very name of the Factor language.  By contrast, an applicative program laden
with variables and syntactic noise requires more work to refactor: identifying
free variables, pulling out the right functions without causing finicky syntax
errors, calling a new function with the right variables, etc.  Though Factor's
stack-based paradigm is atypical, it is part of a design philosophy that aims
to produce readable programs.

\begin{itemize}

\item Stack effects
      \begin{itemize}
        \item Basic stack effects: stack shufflers illustrated
        \item Complex stack effects: row polymorphism \& types
        \item Stack checker
      \end{itemize}

\item Combinators
      \begin{itemize}
        \item Control flow
              \begin{itemize}
                \item if
                \item each
                \item while
              \end{itemize}
        \item Data flow
              \begin{itemize}
                \item Dip/keep
                \item Cleave
                \item Spread
                \item Apply
              \end{itemize}
      \end{itemize}

\item Object system
      \begin{itemize}
        \item tuples
        \item generics \& methods
      \end{itemize}

\item Libraries \& metaprogramming
      \begin{itemize}
        \item Results of evolution
        \item locals?
        \item fry?
        \item macros?
        \item functors?
        \item ffi?
      \end{itemize}

\end{itemize}

\end{document}
