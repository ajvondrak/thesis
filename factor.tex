\section{Language Primer}\label{sec:primer}

\todo[inline]{citations for this history are fragmented across the internet}

Factor is a rather young language created by Slava Pestov in September of 2003.
Its first incarnation targeted the \gls{JVM} as an embedded scripting language
for a game.  As such, its feature set was minimal.  Factor has since evolved
into a general-purpose programming language, gaining new features and
redesigning old ones as necessary for larger programs.  Today's implementation
sports an extensive standard library and has moved away from the \gls{JVM} in
favor of native code generation.  In this \lcnamecref{sec:primer}, we cover the
basic syntax and semantics of Factor for those unfamiliar with the language.
This should be just enough to understand the later material in this thesis.
More thorough documentation can be found via Factor's website,
\url{http://factorcode.org}.

\subsection{Stack-Based Languages}\label{sec:primer:stack-based}

\inputfig{rpn}

Like \gls{RPN} calculators, Factor's evaluation model uses a global stack upon
which operands are pushed before operators are called.  This naturally
facilitates postfix notation, in which operators are written after their
operands.  For example, instead of \texttt{1~+~2}, we write \texttt{1~2~+}.
\vref{fig:rpn} shows how \texttt{1~2~+} works conceptually:
\begin{itemize}
  \item \texttt{1} is pushed onto the stack
  \item \texttt{2} is pushed onto the stack
  \item \texttt{+} is called, so two values are popped from the stack, added,
        and the result (\texttt{3}) is pushed back onto the stack
\end{itemize}
Other stack-based programming languages include Forth\todo{cite},
Joy\todo{cite}, Cat\todo{cite}, and PostScript\todo{cite}.

The strength of this model is its simplicity.  Evaluation essentially goes
left-to-right: literals (like \texttt{1} and \texttt{2}) are pushed onto the
stack, and operators (like \texttt{+}) perform some computation using values
currently on the stack.  This ``flatness'' makes parsing easier, since we don't
need complex grammars with subtle ambiguities and precedence issues.  Rather,
we basically just scan left-to-right for tokens separated by whitespace.  In
the Forth tradition, functions are called \term{words} since they're made up of
any contiguous non-whitespace characters.  This also lends to the term
\term{vocabulary} instead of ``module'' or ``library''.   In Factor, the parser
works as follows.
\begin{itemize}
  \item If the current character is a double-quote (\texttt{"}), try to
        parse ahead for a string literal.
  \item Otherwise, scan ahead for a single token.
        \begin{itemize}
          \item If the token is the name of a \term{parsing word}, that word is
                invoked with the parser's current state.
          \item If the token is the name of an ordinary (i.e., non-parsing)
                word, that word is added to the parse tree.
          \item Otherwise, try to parse the token as a numeric literal.
        \end{itemize}
\end{itemize}

Parsing words serve as hooks into the parser, letting Factor users extend the
syntax dynamically.  For instance, instead of having special knowledge of
comments built into the parser, the parsing word \texttt{!}~scans forward for a
newline and discards any characters read (adding nothing to the parse tree).

Similarly, there are parsing words for what might otherwise be hard-coded
syntax for data structure literals.  Many act as sided delimeters: the parsing
word for the left-delimiter will parse ahead until it reaches the
right-delimiter, using whatever was read in between to add objects to the data
structure.  For example, \factor|{ 1 2 3 }| denotes an array of three numbers.
Note the deliberate spaces in between the tokens, so that the delimeters are
themselves distinct words.  In
%
\Verb[showspaces]|{ 1 2 3 }| (with spaces as marked), the parsing word \Verb|{|
parses objects until it reaches \Verb|}|, collecting the results into an array.
The \verb|{| word would not be called if not for that space, whereas
%
\Verb[showspaces]|{1 2 3}| parses as the word \Verb|{1|, the number \Verb|2|,
and the word \Verb|3}|---not an array.  Further, since the left-delimeter words
parse recursively, such literals can be nested, contain comments, etc.  Other
literals include \vpageref[the following][those in
\vref{lst:literals}~]{lst:literals}.

\inputlst[h]{literals}

\inputfig{quot}

A particularly important set of parsing words in Factor are the square
brackets, \Verb|[| and \Verb|]|.  Any code in between such brackets is
collected up into a special sequence called a \term{quotation}.  Essentially,
it's a snippet of code whose execution is suppressed.  The code inside a
quotation can then be run with the \factor|call| word.  Quotations are like
anonymous functions in other languages, but the stack model makes them
conceptually simpler, since we don't have to worry about variable binding and
the like.  Consider a small example like \factor|1 2 [ + ] call|.  You can
think of \factor|call| working by ``erasing'' the brackets around a quotation,
so this example behaves just like \factor|1 2 +|.  \vref{fig:quot} shows its
evaluation: instead of adding the numbers immediately, \factor|+| is placed in
a quotation, which is pushed to the stack.  The quotation is then invoked by
\factor|call|, so \factor|+| pops and adds the two numbers and pushes the
result onto the stack.  We'll show how quotations are used in
\cref{sec:primer:combinators}.

\subsection{Stack Effects}\label{sec:primer:effects}

Everything else about Factor follows from the stack-based structure outlined in
\cref{sec:primer:stack-based}.  Consecutive words transform the stack in
discrete steps, thereby shaping a result.  In a way, words are functions from
stacks to stacks---from ``before'' to ``after''---and whitespace is effectively
function composition.  Even literals (numbers, strings, arrays, quotations,
etc.) can be thought of as functions that take in a stack and return that stack
with an extra element pushed onto it.

With this in mind, Factor requires that the number of elements on the stack
(the \term{stack height}) is known at each point of the program in order to
ensure consistency.  To this end, every word is associated with a \term{stack
effect} declaration using a notation implemented by parsing words.  In general,
a stack effect declaration has the form
%
\begin{center} \factor|( input1 input2 ... -- output1 output2 ... )|
\end{center}
%
\noindent where the parsing word \Verb|(| scans forward for the special token
\Verb|--| to separate the two sides of the declaration, and then for the
\Verb|)| token to end the declaration.  The names of the intermediate tokens
don't technically matter---only how many of them there are.  However, names
should be meaningful for clarity's sake.  The number of tokens on the left side
of the declaration (before the \Verb|--|) indicates the minimum stack height
expected before executing the word.  Given exactly this number of inputs, the
number of tokens on the right side is the stack height after executing the
word.

For instance, the stack effect of the \factor|+| word is
%
\factor|( x y -- z )|,
%
as it pops two numbers off the stack and pushes one number (their sum) onto the
stack.  This could be written any number of ways, though.
%
\factor|( x x -- x )|,
%
\factor|( number1 number2 -- sum )|,
%
and
%
\factor|( m n -- m+n )|
%
are all equally valid.  Further, while the stack effect
%
\factor|( junk x y -- junk z )|
%
has the same relative height change, this declaration would be wrong, since
\factor|+| might legitimately be called on only two inputs.

\inputfig{shufflers}

For the purposes of documentation, of course, the names in stack effects do
matter.  They correspond to elements of the stack from bottom-to-top.  So, the
rightmost value on either side of the declaration names the top element of the
stack.  We can see this in \vref{fig:shufflers}, which shows the effects of
standard \term{stack shuffler} words.  These words are used for basic data flow
in Factor programs.  For example, to discard the top element of the stack, we
use the \factor|drop| word, whose effect is simply
%
\factor|( x -- )|.
%
To discard the element just below the top of the stack, we use \factor|nip|,
whose effect is
%
\factor|( x y -- y )|.
%
This stack effect indicates that there are at least two elements on the stack
before \factor|nip| is called: the top element is \factor|y|, and the next
element is \factor|x|.  After calling the word, \factor|x| is removed, leaving
the original \factor|y| still on top of the stack.  Other shuffler words that
remove data from the stack are
%
\factor|2drop| with the effect \factor|( x y -- )|,
%
\factor|3drop| with the effect \factor|( x y z -- )|, and
%
\factor|2nip| with the effect \factor|( x y z -- z )|.

The next stack shufflers duplicate data.  \factor|dup| copies the top element
of the stack, as indicated by its effect \factor|( x -- x x )|.  \factor|over|
has the effect \factor|( x y -- x y x )|, which tells us that it expects at
least two inputs: the top of the stack is \factor|y|, and the next object is
\factor|x|.  \factor|x| is copied and pushed on top of the two original
elements, sandwiching \factor|y| between two \factor|x|s.  Other shuffler words
that duplicate data on the stack are
%
\factor|2dup| with the effect \factor|( x y -- x y x y )|,
%
\factor|3dup| with the effect \factor|( x y z -- x y z x y z )|,
%
\factor|2over| with the effect \factor|( x y z -- x y z x y )|, and
%
\factor|pick| with the effect \factor|( x y z -- x y z x )|.

True to the name \factor|swap|, the final shuffler in \vref{fig:shufflers}
permutes the top two elements of the stack, reversing their order.  The stack
effect
%
\factor|( x y -- y x )|
%
indicates as much.  The left side denotes that two inputs are on the stack (the
top is \factor|y|, the next is \factor|x|), and the right side shows the
outputs are swapped (the top element is \factor|x| and the next is \factor|y|).
Factor has other words that permute elements deeper into the stack.  However,
their use is discouraged because it's harder for the programmer to mentally
keep track of more than a couple items on the stack.  We'll see how more
complex data flow patterns are handled in \cref{sec:primer:data-flow}.

\subsection{Definitions}\label{sec:primer:colon-defs}

\inputlst{hello-world}

\inputlst{norm}

Using the basic syntax of stack effect declarations described in
\cref{sec:primer:effects}, we can now understand how to define words.  Most
words are defined with the parsing word \factor|:|, which scans for a name, a
stack effect, and then any words up until the \factor|;| token, which together
become the body of the definition.  Thus, the classic example in
\vref{lst:hello-world} defines a word named \factor|hello-world| which expects
no inputs and pushes no outputs onto the stack.  When called, this word will
display the canonical greeting on standard output using the \factor|print|
word.

\inputfig{norm-steps}

A slightly more interesting example is the \factor|norm| word in
\vref{lst:norm}.  This squares each of the top two numbers on the stack, adds
them, then takes the square root of the sum.  \vref{fig:norm-steps} shows this
in action.  By defining a word to perform these steps, we can replace virtually
any instance of
%
\factor|dup * swap dup * + sqrt|
%
in a program simply with \factor|norm|.  This is a deceptively important point.
Data flow is made explicit via stack manipulation rather than being hidden in
variable assignments, so repetitive patterns become painfully evident.  This
makes identifying, extracting, and replacing redundant code easy.  Often, you
can just copy a repetitive sequence of words into its own definition verbatim.
This emphasis on ``factoring'' your code is what gives Factor its name.

\inputlst{norm-factored}

As a simple case in point, we see the subexpression \factor|dup *| appears
twice in the definition of \factor|norm| in \vref{lst:norm}.  We can easily
factor that out into a new word and substitute it for the old expressions, as
in \vref{lst:norm-factored}.  By contrast, programs in more traditional
languages are laden with variables and syntactic noise that require more work
to refactor: identifying free variables, pulling out the right functions
without causing finicky syntax errors, calling a new function with the right
variables, etc.  Though Factor's stack-based paradigm is atypical, it is part
of a design philosophy that aims to facilitate readable code focusing on short,
reusable definitions.

\subsection{Object Orientation}

You may have noticed that the examples in \cref{sec:primer:colon-defs} did not
use type declarations.  While Factor is dynamically typed for the sake of
simplicity, it does not do away with types altogether.  In fact, Factor is
object-oriented.  However, its object system doesn't rely on classes possessing
particular methods, as is common.  Instead, it uses \term{generic words} with
methods implemented for particular classes.  To start, though, we must see how
classes are defined.

\subsubsection{Tuples}

\inputlst{tuples}

The central data type of Factor's object system is called a \term{tuple}, which
is a class composed of named \term{slots}---like instance variables in other
languages.  Tuples are defined with the \factor|TUPLE:| parsing word as shown
in \vref{lst:tuples}.  A class name is specified first; if it is followed by
the \factor|<| token and a superclass name, the tuple inherits the slots of the
superclass.  If no superclass is specified, the default is the \factor|tuple|
class.

Slots can be specified in several ways.  The simplest is to just provide a
single token, which is the name of the slot.  This slot can then hold any type
of object.  Using the syntax
%
\factor|{ name class }|,
%
a slot can be limited to hold only instances of a particular class, like
\factor|integer| or \factor|string|.  There are other forms of slot specifiers,
which we will cover after some examples.

\inputlst{colors}

Consider the two tuples defined in \vref{lst:colors}.  The first,
\factor|color|, has no slots.  With every tuple, a class predicate is defined
with the stack effect
%
\verb|( object -- ? )|
%
whose name is the class suffixed by a question mark.  Here, the word
\factor|color?| is defined, which pushes a boolean (in Factor, either
\factor|t| or \factor|f|) indicating whether the top element of the stack is an
instance of the \factor|color| class.  The second tuple, \factor|rgb|, inherits
from the \factor|color| class.  While this doesn't give \factor|rgb| any
different slots, it does mean that an instance of \factor|rgb| will return
\factor|t| for \factor|color?| due to the ``is-a'' relationship between
subclass and superclass.  The word \factor|rgb?| is similarly defined.

Notice that the \factor|rgb| tuple declares three slots named \factor|red|,
\factor|green|, and \factor|blue|.  Since the slots' classes aren't declared,
any sort of object can be stored in them.  A set of methods are defined to
manipulate an \factor|rgb| instance's slots.  Three \term{reader} words are
defined (one for each slot), analogous to ``getter'' methods in other
languages.  Following the template for naming reader words, this example
defines \factor|red>>|, \factor|green>>|, and \factor|blue>>|.  Each word has
the stack effect
%
\factor|( object -- value )|,
%
and extracts the value corresponding to the eponymous slot.  Similarly, the
\term{writer} words \factor|red<<|, \factor|green<<|, and \factor|blue<<| each
have the stack effect
%
\factor|( value object -- )|,
%
and store values in the corresponding \factor|rgb| slots destructively.  To
leave the modified \factor|rgb| instance on the stack while setting slots, the
\term{setter} words \factor|>>red|, \factor|>>green|, and \factor|>>blue| are
also defined, each with the stack effect
%
\factor|( object value -- object' )|.
%
These words are defined in terms of writers.  For instance, \factor|>>red| is
the same as \factor|over red<<|, since \factor|over| copies a reference to the
tuple (i.e., it doesn't make a ``deep'' copy).

To construct an instance of a tuple, we can use either \factor|new| or
\factor|boa|.  \factor|new| will not initialize any of the slots to a
particular input value---all slots will default to Factor's canonical false
value, \factor|f|.  \factor|new| is used in \vref{lst:colors} to define
\factor|<color>| (by convention, the constructor for \factor|foo| is named
\factor|<foo>|).  First, we push the class \factor|color| onto the stack (this
word is also automatically defined by \factor|TUPLE:|), then just call
\factor|new|, leaving a new instance on the stack.  Since this particular tuple
has no slots, using \factor|new| makes sense.  We might also use it to
initialize a class, then use setter words to only assign a particular subset of
slots' values.

However, we often want to initialize a tuple with values for each of its slots.
For this, we have \factor|boa|, which works similarly to \factor|new|.  This is
used in the definition of \factor|<rgb>| in \vref{lst:colors}.  The difference
here is the additional inputs on the stack---one for each slot, in the order
they're declared.  That is, we're constructing the tuple \textbf{b}y
\textbf{o}rder of \textbf{a}rguments, giving us the fun pun ``\factor|boa|
constructor''.  So, \factor|1 2 3 <rgb>| will construct an \factor|rgb|
instance with the \factor|red| slot set to \factor|1|, the \factor|green| slot
set to \factor|2|, and the \factor|blue| slot set to \factor|3|.

\inputlst{email}

Now that we've seen the various words defined for tuples, we can explore more
complex slot specifiers.  Using the array-like syntax from before, slot
specifiers may be marked with certain \term{attributes}---both with the class
declared (like
%
\factor|{ name class attributes... }|)
%
and without the class declared (as in 
%
\factor|{ name attributes... }|).
%
In particular, Factor recognizes two different attributes.  If a slot marked
\factor|read-only|, the writer (and thus setter) for the slot will not be
defined, so the slot cannot be altered.  A slot may also provide an initial
value using the syntax \factor|initial: some-literal|.  This will be the slot's
value when instantiated with \factor|new|. 

For example, \vref{lst:email} shows a tuple definition from Factor's
\factor|smtp| vocabulary that defines an \factor|email| object.  The
\factor|from| address, \factor|subject|, and \factor|body| must be instances of
\factor|string|, while \factor|to|, \factor|cc|, and \factor|bcc| are
\factor|array|s of destination addresses.  The \factor|content-type| slot must
also be a \factor|string|, but if unspecified, it defaults to
\factor|"text/plain"|.  The \factor|encoding| must be a \factor|word| (in
Factor, even words are first-class objects), which by default is \factor|utf8|,
a word from the \factor|io.encodings.utf8| vocabulary for a Unicode format.

\subsubsection{Generics and Methods}

Unlike more common object systems, we do not define individual methods that
``belong'' to particular tuples.  In Factor, you define a method that
specializes on a class for a particular generic word.  That way, when the
generic word is called, it dispatches on the class of the object, invoking the
most specific method for the object.

Generic words are declared with the syntax
%
\factor|GENERIC: word-name ( stack -- effect )|.
%
Words defined this way will then dispatch on the class of the top element of
the stack (necessarily the rightmost input in the stack effect).  To define a
new method with which to control this dispatch, we use the syntax
%
\factor|M: class word-name definition... ;|.

\inputlst{sets}

An accessible example of a generic word is in Factor's \factor|sets|
vocabulary.  \factor|set| is a \term{mixin} class---a union of other classes
whose members may be extended by the user.  We can see the standard definition
in \vref{lst:sets}.  Note that the \factor|USING:| form specifies vocabularies
being used (like Java's \mint{java}|import|), and \factor|IN:| specifies the
vocabulary in which the definitions appear (like Java's \mint{java}|package|).
We can see here that instances of the \factor|sequence|, \factor|hash-set|, and
\factor|bit-set| classes are all instances of \factor|set|, so will respond
\factor|t| to the predicate \factor|set?|.  Similarly, \factor|sequence| is a
mixin class with many more members, including \factor|array|, \factor|vector|,
and \factor|string|.

\inputlst{cardinality}

\vref{lst:cardinality} shows the \factor|cardinality| generic from Factor's
\factor|sets| vocabulary, along with its methods.  This generic word takes a
\factor|set| instance from the top of the stack and pushes the number of
elements it contains.  For instance, if the top element is a \factor|bit-set|,
we extract its \factor|table| slot and invoke another word, \factor|bit-count|,
on that.  But if the top element is \factor|f| (the canonical false/empty
value), we know the cardinality is $0$.  For any \factor|sequence|, we may
offshore the work to a different generic, \factor|length|, defined in the
\factor|sequences| vocabulary.  The final method gives a default behavior for
any other \factor|set| instance, which simply uses \factor|members| to obtain
an equivalent \factor|sequence| of set members, then calls \factor|length|.

By viewing a class as a set of all objects that respond positively to the class
predicate, we may partially order classes with the subset relationship.  Method
dispatch will use this ordering when \factor|cardinality| is called to select
the most specific method for the object being dispatched upon.  For instance,
while no explicit method for \factor|array| is defined, any instance of
\factor|array| is also an instance of \factor|sequence|.  In turn, every
instance of \factor|sequence| is also an instance of \factor|set|.  We have
methods that dispatch on both \factor|set| and \factor|sequence|, but the
latter is more specific, so that is the method invoked.  If we define our own
class, \factor|foo|, and declare it as an instance of \factor|set| but not as
an instance of \factor|sequence|, then the \factor|set| method of
\factor|cardinality| will be invoked.  Sometimes resolving the precedence gets
more complicated, but these edge-cases are beyond the scope of our discussion.

\subsection{Combinators}\label{sec:primer:combinators}

Quotations, introduced in \cref{sec:primer:stack-based}, form the basis of both
control flow and data flow in Factor.  Not only are they the equivalent of
anonymous functions, the stack model makes them syntactically lightweight
enough to serve as blocks of code, akin to the use of curly braces in Java or
C.  The higher-order words that make use of quotations on the stack are called
\term{combinators}.  It's simple to express familiar conditional logic and
loops using combinators, as we'll show in \cref{sec:primer:control-flow}.  In
the presence of explicit data flow via stack operations, even more patterns
arise that can be abstracted away.  \cref{sec:primer:data-flow} explores how we
can use combinators to express otherwise convoluted stack-shuffling logic more
succinctly.

\subsubsection{Control Flow}\label{sec:primer:control-flow}

\subsubsection{Data Flow}\label{sec:primer:data-flow}
