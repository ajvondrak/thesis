%TODO Figure out general subfiles strategy, makefiles, etc.

\documentclass[11pt]{article}

\usepackage{todonotes}
\usepackage{fullpage}
\usepackage{glossaries}

\newacronym{JVM}{JVM}{Java Virtual Machine}
\newacronym{RPN}{RPN}{Reverse Polish Notation}

% BIG TODO: figure this shit out
\newcommand{\term}[1]{\textbf{#1\todo{figure out how terms will work}}}

\begin{document}

\section{Language Primer}

\todo[inline]{citations for this history are fragmented across the internet;
should consolidate some kernel of citation from it}

Factor is a rather young language created by Slava Pestov in September of 2003.
Its first incarnation targeted the \gls{JVM} as an embedded scripting language
for a game.  As such, its feature set was minimal.  Factor has since evolved
into a general-purpose programming language, gaining new features and
redesigning old ones as necessary for larger programs.  Today's implementation
sports an extensive standard library and has moved away from the \gls{JVM} in
favor of native code generation.  In this section\todo{figure out section /
chapter names}, we cover the basic syntax and semantics of Factor for those
unfamiliar with the language.  This should be just enough to understand the
later material in this thesis\todo{cite chapter?}.  More thorough documentation
can be found via Factor's website\todo{cite factorcode.org}.

\subsection{Stack-Based Programming}

Like \gls{RPN} calculators, Factor's essential evaluation model uses a global
\term{stack} upon which operands are pushed before operators are called.  This
lends itself to \term{postfix} notation, in which operators are written after
their operands.  For example, instead of \verb|1 + 2|, we write \verb|1 2 +|.

\begin{itemize}

\item Basic syntax \& semantics
      \begin{itemize}
        \item Postfix example (RPN with a stack, \verb|1 2 +| sort of thing)
        \item Other stack-based languages
        \item Parsing algorithm
              \begin{itemize}
                \item \verb|"|
                \item token
                      \begin{itemize}
                        \item ordinary word (terminology, incl. ``vocabulary'')
                        \item parsing word
                      \end{itemize}
                \item number
              \end{itemize}
        \item Example ordinary words: stack shufflers
        \item Example parsing words: quotations
      \end{itemize}

\item Concatenative programming
      \begin{itemize}
        \item ``Pipeline code''
        \item Whitespace = function composition
        \item Point-free style
        \item Origin of name ``Factor''
      \end{itemize}

\item Stack effects
      \begin{itemize}
        \item Basic stack effects: stack shufflers illustrated
        \item Complex stack effects: row polymorphism \& types
        \item Stack checker
      \end{itemize}

\item Control flow
      \begin{itemize}
        \item Combinators
              \begin{itemize}
                \item if
                \item each
                \item while
              \end{itemize}
        \item Dataflow combinators
              \begin{itemize}
                \item Dip/keep
                \item Cleave
                \item Spread
                \item Apply
              \end{itemize}
      \end{itemize}

\item Object system
      \begin{itemize}
        \item tuples
        \item generics \& methods
      \end{itemize}

\item Libraries \& metaprogramming
      \begin{itemize}
        \item Results of evolution
        \item locals?
        \item fry?
        \item macros?
        \item functors?
        \item ffi?
      \end{itemize}

\end{itemize}

\end{document}
