\documentclass{beamer}

\usepackage{stacks} % custom commands for typesetting stacks

\usepackage{listings,bold-extra}
\lstset{basicstyle=\ttfamily,
        mathescape=true,
        keepspaces=false,
        morekeywords={:=,+,-,*,/,goto,if,<,<=,>,>=,=}}
\usepackage{tikz}
\usetikzlibrary{shapes.misc}

\usepackage{../lib/minted}
\usemintedstyle{bw}
\newminted{factor}{gobble=0,frame=none}
\newmint{factor}{}

\usepackage{graphicx}
\newcommand{\whenNewer}[3]{%
  \ifnum\pdfstrcmp{\pdffilemoddate{#1}}%
  {\pdffilemoddate{#2}}>0%
  {\immediate\write18{#3}}\fi%
}
\newcommand{\includesvg}[2][]{%
  \whenNewer{#2.svg}{#2.pdf}%
    {inkscape -z -D --file=#2.svg --export-pdf=#2.pdf}%
  \includegraphics[#1]{#2.pdf}%
}

\mode<presentation>{
  \usetheme{CambridgeUS}
  \useoutertheme{infolines}
  \setbeamertemplate{navigation symbols}{}
  \AtBeginSection[]{\frame{\tableofcontents[currentsection]}}
}

\title{Global Value Numbering in Factor}
\author{Alex Vondrak}
\institute{\texttt{ajvondrak@csupomona.edu}}
\date{September 1, 2011}
\pgfdeclareimage[width=0.5\textwidth]{logo}{dependencies.png}
\titlegraphic{\pgfuseimage{logo}}

\begin{document}

\maketitle

\begin{frame}{Factor}
  Factor (\url{http://factorcode.org/})
  \begin{itemize}
    \item Started development September 2003---a baby among languages
    \item \alert{Stack-based}
    \item Object-oriented
    \item Dynamically typed
    \item Extensive standard library
    \item High-level, yet fully \alert{compiled}
  \end{itemize}

  Won't really have time to discuss the language in depth
\end{frame}

\begin{frame}[fragile]{Stacks as an Evaluation Model}
  \begin{example}[Code]
    \begin{verbatim}
1 2 +
    \end{verbatim}
  \end{example}

  \begin{example}[Execution]
    \begin{columns}[c,onlytextwidth]
      \begin{column}[c]{.5\textwidth}
        \begin{verbatim}
push(1);
push(2);
y = pop();   // y = 2;
x = pop();   // x = 1;
push(x + y); // push(3);
        \end{verbatim}
      \end{column}

      \begin{column}[c]{.5\textwidth}
        \stackop{3}{+}{1 2 ~}{3 ~}
      \end{column}
    \end{columns}
  \end{example}
\end{frame}

\section{Compiler}

\subsection{Structure}

\begin{frame}{Organization}
  Non-optimizing base compiler
  \begin{itemize}
    \item VM written in C++
    \item Responsible for basic runtime services
    \begin{itemize}
      \item Garbage collection
      \item Method dispatch
      \item Polymorphic inline caches
      \item \ldots
    \end{itemize}
    \item Single pass---outputs assembly stubs for primitives
  \end{itemize}

  \alert{Optimizing compiler}
  \begin{itemize}
    \item Written in Factor code
    \begin{itemize}
      \item Possible by \emph{bootstrapping}
    \end{itemize}
    \item Optimizes in passes across two \alert{intermediate representations}
    (IRs)
    \begin{itemize}
      \item High-level IR (\texttt{compiler.tree})
      \item Low-level IR (\texttt{compiler.cfg})
    \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}{High-level IR}
  \begin{itemize}
    \item Tree of \texttt{node} objects
    \item Very simple virtual instruction set
    \begin{itemize}
      \item \texttt{\#introduce}, \texttt{\#return}
      \item \texttt{\#push} \& \texttt{\#call}
      \item \texttt{\#renaming}---\texttt{\#copy} \& \texttt{\#shuffle}
      \item \texttt{\#declare} \& \texttt{\#terminate}
      \item \texttt{\#branch}---\texttt{\#if} \& \texttt{\#dispatch}
      \item \texttt{\#phi}
      \item \texttt{\#recursive}, \texttt{\#enter-recursive},
            \texttt{\#call-recursive}, \texttt{\#return-recursive}
      \item \texttt{\#alien-node}, \texttt{\#alien-invoke},
            \texttt{\#alien-indirect}, \texttt{\#alien-assembly},
            \texttt{\#alien-callback}
    \end{itemize}
    \item Input/output values of stack given unique names
  \end{itemize}
\end{frame}

\begin{frame}[fragile]{High-level IR}{\texttt{1~2~+}}
  \begin{example}
    \begin{verbatim}
V{
    T{ #push { literal 1 } { out-d { 6256273 } } }
    T{ #push { literal 2 } { out-d { 6256274 } } }
    T{ #call
        { word + }
        { in-d V{ 6256273 6256274 } }
        { out-d { 6256275 } }
    }
    T{ #return { in-d V{ 6256275 } } }
}
    \end{verbatim}
  \end{example}
\end{frame}

\begin{frame}[fragile]{Low-level IR}
  \begin{itemize}
    \item Control flow graph (CFG)
    \begin{itemize}
      \item Basic blocks = maximal sequence of ``straight-line'' code
      \item Directed edges = transfer of control flow
    \end{itemize}
    \item \texttt{insn} objects modeled closely after assembly-like
          instructions
    \item \alert{Static single assignment} (SSA) form
  \end{itemize}
  \begin{onlyenv}<1>
  \begin{center}
    \begin{minipage}{0.4\linewidth}
      \begin{tikzpicture}[node distance=0.6in,>=latex]
      \node[draw,label=right:{\small $B_1$}] (1) at (0,-1)
        {\lstinline|if $P$ goto $B_3$|};
      \node[draw,label=left:{\small $B_2$}] (2) [below left of=1]
        {\lstinline|x := 5|};
      \node[draw,label=right:{\small $B_3$}] (3) [below right of=1]
        {\lstinline|x := 10|};
      \node[draw,label=right:{\small $B_4$}] (4) [below right of=2]
        {\lstinline|y := x + 1|};

      \draw[->] (0,0) -- (1);
      \draw (1) edge[->] (2)
                edge[->] (3)
            (2) edge[->] (4)
            (3) edge[->] (4);
      \end{tikzpicture}
    \end{minipage}
    \vrule
    \begin{minipage}{0.4\linewidth}
      \begin{tikzpicture}[node distance=0.6in,>=latex]
      \node[draw,label=right:{\small $B_1$}] (1) at (0,-1)
        {\lstinline|if $P$ goto $B_3$|};
      \node[draw,label=left:{\small $B_2$}] (2) [below left of=1]
        {\lstinline|x$_0$ := 5|};
      \node[draw,label=right:{\small $B_3$}] (3) [below right of=1]
        {\lstinline|x$_1$ := 10|};
      \node[draw,label=right:{\small $B_4$}] (4) [below right of=2]
        {\lstinline|y$_{~}$ := x$_?$ + 1|};

      \draw[->] (0,0) -- (1);
      \draw (1) edge[->] (2)
                edge[->] (3)
            (2) edge[->] (4)
            (3) edge[->] (4);
      \end{tikzpicture}
    \end{minipage}
  \end{center}
  \end{onlyenv}
  \begin{onlyenv}<2>
  \begin{center}
  \begin{tikzpicture}[node distance=0.7in,>=latex]
  \node[draw,label=right:$B_1$] (1) at (0,-1) {\lstinline|if $P$ goto $B_3$|};
  \node[draw,label=left:$B_2$] (2) [below left of=1] {\lstinline|x$_0$ := 5|};
  \node[draw,label=right:$B_3$] (3) [below right of=1] {\lstinline|x$_1$ := 10|};
  \node[draw,label=right:$B_4$] (4) [below right of=2] {
  \begin{lstlisting}
x$_2$ := $\phi$(x$_0$,x$_1$)
y$_{~}$ := x$_2$ + 1
  \end{lstlisting}
  };

  \draw[->] (0,0) -- (1);
  \draw (1) edge[->] (2)
            edge[->] (3)
        (2) edge[->] (4)
        (3) edge[->] (4);
  \end{tikzpicture}
  \end{center}
  \end{onlyenv}
\end{frame}

\subsection{Optimizations}

\begin{frame}[fragile]{Optimizations---High-level IR}
\footnotesize
\begin{center}
\begin{minipage}{0.5\linewidth}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{:} \PY{n+nf}{optimize-tree} \PY{n+nf}{(} \PY{n+nv}{nodes} \PY{n+nf}{--} \PY{n+nv}{nodes'} \PY{n+nf}{)}
  [
      analyze-recursive
      normalize
      propagate
      cleanup
      \PY{k}{dup }run-escape-analysis? [
          escape-analysis
          unbox-tuples
      ] \PY{k}{when}
      apply-identities
      compute-def-use
      remove-dead-code
      ?check
      compute-def-use
      optimize-modular-arithmetic
      finalize
  ] \PY{k}{with-scope ;}
\end{Verbatim}
\end{minipage}
\end{center}
\end{frame}

\begin{frame}[fragile]{Optimizations---Low-level IR}
  \renewcommand{\theFancyVerbLine}{%
    \ifnum\value{FancyVerbLine}=9%
    $\longrightarrow$\else{}\fi}
  \begin{center}
  \begin{minipage}{0.5\linewidth}
  \begin{factorcode*}{linenos}
: optimize-cfg ( cfg -- cfg' )
    optimize-tail-calls
    delete-useless-conditionals
    split-branches
    join-blocks
    normalize-height
    construct-ssa
    alias-analysis
    value-numbering
    copy-propagation
    eliminate-dead-code ;
  \end{factorcode*}
  \end{minipage}
  \end{center}
\end{frame}

\section{Value Numbering}

\begin{frame}{Value Numbering}
  Idea: assign each variable a \alert{value number}
  \begin{itemize}
    \item Equal value numbers $\implies$ equal at runtime
    \item Turn recomputations into \texttt{\#\#copy} instructions, saving time
  \end{itemize}

  General problem is undecidable
  \begin{itemize}
    \item Seek \alert{conservative} solution
    \item Discover \emph{Herbrand equivalences}
    \item Consider two values \alert{congruent} if
    \begin{itemize}
      \item They're computed by the same operator
      \item Their operands are congruent
    \end{itemize}
  \end{itemize}
\end{frame}

\subsection{Local Value Numbering}

\begin{frame}{Local Value Numbering}
  \begin{itemize}
    \item Thought to be invented by Balke in the 1960s
    \item Largely credited to Cocke \& Schwartz in the 1970s
    \item Current implementation Factor uses
  \end{itemize}

  \begin{itemize}
    \item[Pro:] Easy to understand, implement, and extend

    \item[Con:] Is \alert{local} and \alert{pessimistic}, discovering fewer
    congruences
  \end{itemize}
\end{frame}

\begin{frame}[fragile]{Local Value Numbering}{Implementation}
  \begin{itemize}
    \item \alert{Expressions} are constructed from instructions
    \begin{example}
      \begin{Verbatim}
T{ ##add { dst 1 } { src1 2 } { src2 3 } } >expr
{ ##add 2 3 }
      \end{Verbatim}
    \end{example}

    \item \alert{Expression graph} = 3 global hash tables
    \begin{itemize}
      \item \texttt{vregs>vns}
      \item \texttt{exprs>vns}
      \item \texttt{vns>insns}
    \end{itemize}

    \item If possible, instructions are simplified using data from expression
    graph
  \end{itemize}
\end{frame}

\begin{frame}[fragile]{Local Value Numbering}
  \begin{onlyenv}<1>
    \begin{example}[In Factor]
      \factor|0 100 [ 1 fixnum+fast ] times|
    \end{example}
    \begin{example}[In Java]
      \begin{minted}{java}
int i = 0;
for (int j = 0; j < 100; j++) {
  i += 1;
}
      \end{minted}
    \end{example}
  \end{onlyenv}
  \begin{onlyenv}<2>
    \begin{center}
      \includesvg[scale=0.35]{/home/alex/thesis/examples/lvn/7-alias-analysis}
    \end{center}
  \end{onlyenv}
\end{frame}

\begin{frame}[fragile]{Local Value Numbering}{Basic Block 1}
  \begin{onlyenv}<1>
  \begin{Verbatim}
vregs>vns = H{ }
exprs>vns = H{ }
  \end{Verbatim}
  \end{onlyenv}
  \begin{onlyenv}<2>
  \begin{Verbatim}
vregs>vns = H{ { 21 21 } }
exprs>vns = H{ {  0 21 } }
  \end{Verbatim}
  \end{onlyenv}
  \begin{onlyenv}<3>
  \begin{Verbatim}
vregs>vns = H{ { 21 21 } {  22 22 } }
exprs>vns = H{ {  0 21 } { 100 22 } }
  \end{Verbatim}
  \end{onlyenv}
  \begin{onlyenv}<4>
  \begin{Verbatim}
vregs>vns = H{ { 21 21 } {  22 22 } { 23 21 } }
exprs>vns = H{ {  0 21 } { 100 22 } }
  \end{Verbatim}
  \end{onlyenv}
  \begin{onlyenv}<5>
  \begin{Verbatim}
vregs>vns = H{ { 21 21 } {  22 22 } { 23 21 } { 24 22 } ... }
exprs>vns = H{ {  0 21 } { 100 22 } }
  \end{Verbatim}
  \end{onlyenv}
  \begin{columns}[t,onlytextwidth]
    \begin{column}[t]{.45\textwidth}
      \begin{onlyenv}<1-4>
      \begin{Verbatim}[frame=single]
##inc-d 3
##load-integer 21 0
##load-integer 22 100
##load-integer 23 0
##copy 24 22 any-rep
##copy 25 21 any-rep
##copy 26 24 any-rep
##copy 27 23 any-rep
##branch
      \end{Verbatim}
      \end{onlyenv}
      \begin{onlyenv}<5->
      \begin{Verbatim}[frame=single]
##inc-d 3
##load-integer 21 0
##load-integer 22 100
##copy 23 21 any-rep
##copy 24 22 any-rep
##copy 25 21 any-rep
##copy 26 24 any-rep
##copy 27 23 any-rep
##branch
      \end{Verbatim}
      \end{onlyenv}
    \end{column}

    \begin{column}[t]{.5\textwidth}
      \begin{onlyenv}<1>
        \begin{Verbatim}
(no-op)
        \end{Verbatim}
      \end{onlyenv}
      \begin{onlyenv}<2>
        \begin{Verbatim}
(no-op)
>expr = 0
        \end{Verbatim}
      \end{onlyenv}
      \begin{onlyenv}<3>
        \begin{Verbatim}
(no-op)
>expr = 0
>expr = 100
        \end{Verbatim}
      \end{onlyenv}
      \begin{onlyenv}<4>
        \begin{Verbatim}
(no-op)
>expr = 0
>expr = 100
>expr = 0
        \end{Verbatim}
      \end{onlyenv}
      \begin{onlyenv}<5>
        \begin{Verbatim}
(no-op)
>expr = 0
>expr = 100
>expr = 0
...
...
...
...
        \end{Verbatim}
      \end{onlyenv}
    \end{column}
  \end{columns}
\end{frame}

\begin{frame}[fragile]{Local Value Numbering}{Basic Block 2}
  \begin{onlyenv}<1>
  \begin{Verbatim}
vregs>vns = H{ }
exprs>vns = H{ }
  \end{Verbatim}
  \end{onlyenv}
  \begin{onlyenv}<2>
  \begin{Verbatim}
vregs>vns = H{ { 30 30 } { 26 26 } { 31 31 } }
exprs>vns = H{ { { ##compare-integer 30 26 cc< } 31 } }
  \end{Verbatim}
  \end{onlyenv}
  \begin{onlyenv}<3->
  \begin{Verbatim}
vregs>vns = H{ { 30 30 } { 26 26 } { 31 31 } ... }
exprs>vns = H{ { { ##compare-integer 30 26 cc< } 31 } }
  \end{Verbatim}
  \end{onlyenv}
  \begin{columns}[t,onlytextwidth]
    \begin{column}[t]{.6\textwidth}
      \begin{onlyenv}<1-3>
      \begin{Verbatim}[frame=single]
##phi 29 H{ { 1 25 } { 3 41 } }
##phi 30 H{ { 1 27 } { 3 42 } }
##compare-integer 31 30 26 cc< 9
##copy 32 31 any-rep
##copy 33 26 any-rep
##copy 34 31 any-rep
##compare-imm-branch 32 f cc/=
      \end{Verbatim}
      \end{onlyenv}
      \begin{onlyenv}<4->
      \begin{Verbatim}[frame=single]
##phi 29 H{ { 1 25 } { 3 41 } }
##phi 30 H{ { 1 27 } { 3 42 } }
##compare-integer 31 30 26 cc< 9
##copy 32 31 any-rep
##copy 33 26 any-rep
##copy 34 31 any-rep
##compare-integer-branch 30 26 cc<
      \end{Verbatim}
      \end{onlyenv}
    \end{column}

    \begin{column}[t]{.3\textwidth}
      \begin{onlyenv}<1>
        \begin{Verbatim}
(no-op)
(no-op)
        \end{Verbatim}
      \end{onlyenv}
      \begin{onlyenv}<2>
        \begin{Verbatim}
(no-op)
(no-op)
>expr = ...
        \end{Verbatim}
      \end{onlyenv}
      \begin{onlyenv}<3->
        \begin{Verbatim}
(no-op)
(no-op)
>expr = ...
...
...
...
        \end{Verbatim}
      \end{onlyenv}
    \end{column}
  \end{columns}
\end{frame}

\begin{frame}[fragile]{Local Value Numbering}{Basic Block 3}
  \begin{onlyenv}<1>
  \begin{Verbatim}
vregs>vns = H{ }
exprs>vns = H{ }
  \end{Verbatim}
  \end{onlyenv}
  \begin{onlyenv}<2>
  \begin{Verbatim}
vregs>vns = H{ { 35 35 } }
exprs>vns = H{ {  1 35 } }
  \end{Verbatim}
  \end{onlyenv}
  \begin{onlyenv}<3>
  \begin{Verbatim}
vregs>vns = H{ { 35 35 } { 29 29 } { 36 36 } }
exprs>vns = H{ {  1 35 } { { ##add-imm 29 1 } 36 } }
  \end{Verbatim}
  \end{onlyenv}
  \begin{onlyenv}<4>
  \begin{Verbatim}
vregs>vns = H{ { 35 35 } { 29 29 } { 36 36 }  { 37 35 } }
exprs>vns = H{ {  1 35 } { { ##add-imm 29 1 } 36 } }
  \end{Verbatim}
  \end{onlyenv}
  \begin{onlyenv}<5->
  \begin{Verbatim}
vregs>vns = H{ { 35 35 } { 29 29 } { 36 36 }  { 37 35 } ... }
exprs>vns = H{ {  1 35 } { { ##add-imm 29 1 } 36 } ... }
  \end{Verbatim}
  \end{onlyenv}
  \begin{columns}[t,onlytextwidth]
    \begin{column}[t]{.4\textwidth}
      \begin{onlyenv}<1-3>
      \begin{Verbatim}[frame=single]
##load-integer 35 1
##add 36 29 35
##load-integer 37 1
##add 38 30 37
##copy 39 30 any-rep
##copy 40 26 any-rep
##copy 41 36 any-rep
##copy 42 38 any-rep
##branch
      \end{Verbatim}
      \end{onlyenv}
      \begin{onlyenv}<4>
      \begin{Verbatim}[frame=single]
##load-integer 35 1
##add-imm 36 29 1
##load-integer 37 1
##add 38 30 37
##copy 39 30 any-rep
##copy 40 26 any-rep
##copy 41 36 any-rep
##copy 42 38 any-rep
##branch
      \end{Verbatim}
      \end{onlyenv}
      \begin{onlyenv}<5>
      \begin{Verbatim}[frame=single]
##load-integer 35 1
##add-imm 36 29 1
##copy 37 35 any-rep
##add 38 30 37
##copy 39 30 any-rep
##copy 40 26 any-rep
##copy 41 36 any-rep
##copy 42 38 any-rep
##branch
      \end{Verbatim}
      \end{onlyenv}
      \begin{onlyenv}<6->
      \begin{Verbatim}[frame=single]
##load-integer 35 1
##add-imm 36 29 1
##copy 37 35 any-rep
##add-imm 38 30 1
##copy 39 30 any-rep
##copy 40 26 any-rep
##copy 41 36 any-rep
##copy 42 38 any-rep
##branch
      \end{Verbatim}
      \end{onlyenv}
    \end{column}

    \begin{column}[t]{.5\textwidth}
      \begin{onlyenv}<2>
        \begin{Verbatim}
>expr = 1
        \end{Verbatim}
      \end{onlyenv}
      \begin{onlyenv}<3>
        \begin{Verbatim}
>expr = 1
>expr = { ##add-imm 29 1 }
        \end{Verbatim}
      \end{onlyenv}
      \begin{onlyenv}<4>
        \begin{Verbatim}
>expr = 1
>expr = { ##add-imm 29 1 }
>expr = 1
        \end{Verbatim}
      \end{onlyenv}
      \begin{onlyenv}<5>
        \begin{Verbatim}
>expr = 1
>expr = { ##add-imm 29 1 }
>expr = 1
>expr = { ##add-imm 30 1 }
        \end{Verbatim}
      \end{onlyenv}
      \begin{onlyenv}<6->
        \begin{Verbatim}
>expr = 1
>expr = { ##add-imm 29 1 }
>expr = 1
>expr = { ##add-imm 30 1 }
...
...
...
...
        \end{Verbatim}
      \end{onlyenv}
    \end{column}
  \end{columns}
\end{frame}

\begin{frame}{Local Value Numbering Results}
  \begin{center}
    \includesvg[scale=0.5]{/home/alex/thesis/examples/lvn/11-finalize-cfg}
  \end{center}
\end{frame}

\subsection{Global Value Numbering}

\section{Results}

\end{document}
